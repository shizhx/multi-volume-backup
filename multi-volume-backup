#!/bin/bash
# A smart multi-volume backup script based on `tar`.

prog=$0
cmd=$1

MVB_WORK_DIR=${MVB_WORK_DIR:-"/tmp"}
MVB_CMD=${MVB_CMD:-""}
if [ -z "$cmd" ]; then
    cmd=$MVB_CMD
else
    shift
fi

usage() {
    local prog_name
    prog_name=$(basename "$0")

    echo "Usage:"
    echo "  $prog_name backup <source path> <dest path with volume name prefix> <volume size> <snar file path>"
    echo "  $prog_name restore <first volume path> <dest path>"
    echo
    echo "Note:"
    echo "  snar file record the filelist to achive incremental backup"
    echo
    echo "Example:"
    echo "  multi-volume-backup backup /data /mnt/bak/full_backup- 100G /data.snar"
    echo "  multi-volume-backup restore /mnt/bak/full_backup-1.tar /data"
    exit 1
}

log_tag=""
__log_impl() {
    local now
    now=$(date "+%Y-%m-%d %H:%M:%S")

    echo "$now $*"
}

logi() {
    __log_impl "INFO" "[$log_tag] $*"
}

loge() {
    __log_impl "ERROR" "[$log_tag] $*"
}

logf() {
    __log_impl "FATAL" "[$log_tag] $*"
    exit 2
}


do_backup() {
    log_tag="backup-main"
    local src=$1
    local dst_prefix=$2
    local size=$3
    local snar=$4

    # check argument
    local dst_dir
    local snar_dir

    dst_dir=$(dirname "$dst_prefix")
    snar_dir=$(dirname "$snar")

    [ -d "$src" ] || logf "Invalid source path: $src"
    [ -d "$dst_dir" ] || logf "Invalid dest path $dst_prefix"
    [ -n "$size" ] || logf "Invalid volume size: $size"
    [ -d "$snar_dir" ] || logf "Invalid snar file: $snar"

    # create pipe to recv data and signal
    mkdir -p "$MVB_WORK_DIR" || logf "Failed to create workdir: $MVB_WORK_DIR"
    local data_channel="$MVB_WORK_DIR/mv-backup-data"
    local signal_channel="$MVB_WORK_DIR/mv-backup-signal"
    mkfifo "$data_channel" || logf "Failed to create data channel: $data_channel"
    mkfifo "$signal_channel" || logf "Failed to create signal channel: $signal_channel"

    # writer
    logi "Starting backgroud writer to receive data and write to $dst_dir"
    "$prog" __recv "$dst_prefix" "$data_channel" "$signal_channel" &
    writer_pid=$!

    if ! timeout 10 cat "$signal_channel"; then
        logf "Failed to start backgroud writer"
    fi

    # reader
    logi "Starting reader(tar) to read data and write to data channel"
    # use environment variables to pass arguments to tar script
    export MVB_CMD="__change_volume"
    export MVB_DST_PREFIX="$dst_prefix"
    export MVB_VOL_SIZE="$size"
    export MVB_DATA_CH="$data_channel"
    export MVB_SIGNAL_CH="$signal_channel"
    tar -cM -v -H posix -L "$size" -F "$prog" -f "$data_channel" -g "$snar" "$src"
    
    # notify writer
    logi "tar process exit with code $?, notify backgroud writer"
    echo "EXIT" | timeout 10 tee "$signal_channel"
    if ! timeout 10 wait "$writer_pid"; then
        logi "Writer not exit after timeout, kill it(pid=$writer_pid)"
        kill -9 "$writer_pid"
    fi

    logi "Good Bye!"
}

do_recv() {
    log_tag="backup-writer"
    local dst_prefix=$1
    local data_channel=$2
    local signal_channel=$3
    local vol_num=1

    logi "Writer worker started, notify main process"
    echo "WRITER_STARTED" > "$signal_channel" || logf "Failed to notify main process, exit"

    while true; do
        local dst="${dst_prefix}${vol_num}.tar"
        logi "Begin to receive data and write to $dst"
        local checksum
        checksum=$(tee "$dst" < "$data_channel" | sha256sum | awk '{print $1}')
        if [ $? -ne 0 ]; then
            logf "Failed to write $dst, exit"
        fi

        logi "Finish writing to $dst, sha256sum: $checksum"
        echo "$checksum" > "$dst.sha256sum"

        logi "Waiting for next volume signal"
        local sig
        sig=$(cat "$signal_channel")
        if [ "$sig" = "EXIT" ]; then
            logi "Receive EXIT signal, exit"
            exit 0
        fi

        vol_num=$((vol_num + 1))
    done
}

do_restore() {
    local src="$1"
    local dst="$2"

    [ -z "$src" ] || usage
    [ -z "$dst" ] || usage

    tar -xM -v -F "$prog" -f "$src" "$dst"
}

wait_user_confirm() {
    local answer
    echo "Please mount a new disk/tape to correct mountpoint."
    while true; do
        read -r -p "Are new disk/tape mounted?(Y/n): " answer
        if [ "$answer" = "Y" ]; then
            return 0
        fi
    done
}

get_next_backup_volume() {
    # check environment
    [ -n "$MVB_DST_PREFIX" ] || logf "MVB_DST_PREFIX CANNOT be empty"
    [ -n "$MVB_VOL_SIZE" ] || logf "MVB_VOL_SIZE CANNOT be empty"
    [ -n "$MVB_DATA_CH" ] || logf "MVB_DATA_CH CANNOT be empty"

    {
        local dst_prefix=$MVB_DST_PREFIX
        local dst_dir
        dst_dir=$(dirname "$dst_prefix")

        local size_num=${MVB_VOL_SIZE%?}
        local size_unit=${MVB_VOL_SIZE:-1}
        local avail

        # get availiable space of dest
        avail=$(df -B"$size_unit" "$dst_dir" | awk 'NR==2 {print $4}')
        avail=${avail%?}
        if [ -z "$avail" ]; then
            loge "Failed to get availiable space of $dst_dir"
            wait_user_confirm
        elif [ "$avail" -le "$size_num" ]; then
            loge "Availiable space of $dst_dir too small"
            wait_user_confirm
        fi
    } 1>&2

    echo "$MVB_DATA_CH"
    return 0
}

get_next_restore_volume() {
    local prefix=${TAR_ARCHIVE%-*}
    local suffix=${TAR_ARCHIVE##*-}
    local ext=${suffix#*.}
    local next_vol_name="${prefix}${TAR_VOLUME}.${ext}"

    {
        while ! [ -r "$next_vol_name" ]; do
            loge "$next_vol_name is not readable"
            wait_user_confirm
        done
    } 1>&2

    echo "$next_vol_name"
}

do_change_volume() {
    log_tag="change_volume"
    local next_vol_name

    logi "Preparing volume $TAR_VOLUME"

    case "$TAR_SUBCOMMAND" in
    -c)
        next_vol_name=$(get_next_backup_volume)
        # resume writer
        echo "RESUME" > "$MVB_SIGNAL_CH"
        ;;
    -d|-x|-t)
        next_vol_name=$(get_next_restore_volume)
        ;;
    *)
        exit 1
        ;;
    esac

    echo "$next_vol_name" >&"$TAR_FD"
}

case "$cmd" in
backup)
    do_backup "$@"
    ;;
__recv)
    do_recv "$@"
    ;;
restore)
    do_restore "$@"
    ;;
__change_volume)
    do_change_volume
    ;;
*)
    usage
    ;;
esac